# RAG 教程 10：切块（Chunking）怎么做才不坑

Chunking 决定了检索的上限：切得不对，后面 embedding、索引、rerank 都很难救。

## 1. 为什么要切块
文档通常很长，检索系统不可能把整篇文档当做一个单位：
- 太长：相关信息被噪声淹没
- 太短：关键定义被拆散，命中片段不完整

所以需要把文档切成“信息密度合适”的片段。

## 2. 常见切块策略（从简单到复杂）
### 2.1 按标题切块（推荐作为第一步）
Markdown 有天然结构：`#`、`##`、`###`。
做法：
- 按标题分 section
- 为每个 chunk 保存 `title_path`（标题路径）
优点：语义完整，可读性强；方便引用。

### 2.2 按长度二次切分（目标长度 + overlap）
当某个 section 太长，可以按长度拆：
- 目标长度：例如 200~800 tokens（或粗略用字符数）
- overlap：10%~20% 防止“定义与解释”被切断

`demos/rag_min/src/chunking.py` 采取的就是：
- 先按标题切
- 太长再按字符数切，并 overlap

## 3. 元数据（Metadata）一定要存什么
至少存：
- `source_path`：来自哪个文件
- `chunk_id`：唯一定位
- `title_path`：标题路径（有助于解释命中）
- `text`：片段正文

工程化后建议再加：
- `hash`：用于增量更新与去重
- `char_range`：引用到原文更精确（start/end char）

## 4. 最常见的坑
- **只按固定长度切，不看标题结构**：可读性差，引用体验差
- **overlap 太大**：索引里重复内容多，影响检索结果多样性
- **chunk 太小**：一个 chunk 只剩一句话，缺少定义上下文

## 5. 实操建议（你可以照这个迭代）
1) 先按标题切块 + 适度长度拆分（MVP）
2) 用一小批问题做离线评测（Recall@K）
3) 针对失败样本调 chunking（合并短段、保留列表/代码块等）

---

## 📌 导航
- 上一章：[RAG 教程 00：RAG 是什么](./00_overview.md)
- 下一章：[RAG 教程 20：检索与重排](./20_retrieval_and_rerank.md)
- 返回总览：[根目录学习导航](../../README.md#-专题学习导航prompt--rag--skill)
